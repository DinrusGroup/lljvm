#!/usr/bin/python
# Copyright (c) 2009 David Roberts <d@vidr.cc>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

import os
import sys
import subprocess

# LLJVM root directory
lljvm_dir = os.path.abspath(os.path.dirname(sys.argv.pop(0)))

# dummy file
# TODO: make system-independent
fnull = open('/dev/null', 'w')

def command_exists(name):
    """Returns true iff a command with the given name exists."""
    # TODO: make system-independent
    return subprocess.call(['which', name], stdout=fnull) == 0

# C Compiler
if command_exists('llvm-gcc'): cc = 'llvm-gcc'
elif command_exists('clang'):  cc = 'clang'
else:                          cc = None

# default flags to pass to the compiler
default_cflags = (
    '-D__LLJVM__',
    '-I' + os.path.join(lljvm_dir, 'include', 'lljvm'),
    '-I' + os.path.join(lljvm_dir, 'include', 'newlib'),
    '-fno-builtin-rintl', '-fno-builtin-lrintl', '-fno-builtin-llrintl',
)

# command for executing the LLJVM linker
lljvm_ld_cmd = ('java', '-jar', os.path.join(lljvm_dir, 'lljvm.jar'), 'ld')

# default java classes to link against
default_java_libs = (
    'lljvm.lib.c',
    'lljvm.runtime.System',
    'lljvm.runtime.IO',
    'lljvm.runtime.Posix',
    'lljvm.runtime.Jump',
    'java.lang.Math',
    'lljvm.runtime.Math',
)

# (partial) list of flags that take an argument
# TODO: complete list
takes_argument = ('-MF', '-MT', '-MQ', '-include')

# (partial) list of flags not recognised by llvm-ld
# TODO: need a better way of filtering out invalid flags
invalid_ld_flags = ('-g', '-D', '-pthread', '-shared', '-nostdlib', '-lgcc',
                    '-static-libgcc', '-link')

# template for the launcher script
script_template = \
    '#!/bin/sh\n' \
    'export CLASSPATH="`dirname "$0"`:' \
    + os.path.join(lljvm_dir, 'lljvm.jar') + \
    ':${CLASSPATH-.}"\n' \
    'exec java %s "$0" ${1+"$@"}\n'

def die(message, status=1):
    """Print the given message to stderr and terminate with the given
    status."""
    sys.stderr.write(message)
    sys.exit(status)

def element_startswith(l, s):
    """Returns true iff any of the elements in the given list begin with the
    given string."""
    return reduce(lambda x, y: x or y.startswith(s), l, False)

def remove_filext(s):
    """Remove the file extension from the given string."""
    dot = s.rfind('.')
    if dot == -1: return s
    return s[:dot]

def call_e(*popenargs, **kwargs):
    """Call the given command, exiting if it has a non-zero return code."""
    p = subprocess.Popen(*popenargs, **kwargs)
    if p.wait() != 0: sys.exit(p.returncode)

def parse_argv(separate_sources=True):
    """Parse sys.argv, returning the flags and the output file, and separating
    the sources from the flags if required."""
    flags = []
    output = 'a.out'
    if separate_sources: srcs = []

    while sys.argv:
        arg = sys.argv.pop(0)
        if separate_sources and arg[0] != '-':
            srcs.append(arg)
        elif arg == '-o':
            output = sys.argv.pop(0)
        elif arg in takes_argument:
            flags.append(arg)
            flags.append(sys.argv.pop(0))
        else:
            flags.append(arg)
    
    if separate_sources:
        return flags, output, srcs
    return flags, output

def bc2class(output):
    """Generate {output}.class from {output}.bc and unlink {output}.bc"""
    output_j = open(output + '.j', 'w')
    backend_process = subprocess.Popen(
        [os.path.join(lljvm_dir, 'lljvm-backend'), output + '.bc'],
        stdout=subprocess.PIPE)
    linker_returncode = subprocess.Popen(
        lljvm_ld_cmd + default_java_libs,
        stdin=backend_process.stdout, stdout=output_j).wait()
    output_j.close()
    
    if linker_returncode != 0:
        backend_process.kill()
        sys.exit(linker_returncode)
    if backend_process.wait() != 0:
        sys.exit(backend_process.returncode)
    os.unlink(output + '.bc')
    
    outpath = os.path.dirname(output) or '.'
    call_e(['java', 'jasmin.Main', '-d', outpath, output + '.j'], stdout=fnull)
    os.unlink(output + '.j')
    
    script = open(output, 'w')
    script.write(script_template % os.path.basename(output).replace('.', '_'))
    script.close()
    os.chmod(output, 0755)

def remove_non_ld_args(args):
    """Remove arguments not recognised by llvm-ld from the given list, and
    return the new list of arguments."""
    return filter(
        lambda arg:
            arg not in invalid_ld_flags
            and not arg.startswith('-f')
            and not arg.startswith('-D')
            and not arg.startswith('-O')
            and not arg.startswith('-W'),
        args)

def link(ldflags, output):
    """Call llvm-ld with the given flags, and call bc2class on the output."""
    ldflags = remove_non_ld_args(ldflags)
    call_e(['llvm-ld', '--disable-opt', '-o', output] + ldflags)
    os.unlink(output)
    bc2class(output)

def main():
    if not cc: die("Error: either llvm-gcc or clang must be installed")
    if '-link' in sys.argv:
        link(*parse_argv(False)); return
    if '-c' in sys.argv or '-E' in sys.argv:
        call_e([cc, '-emit-llvm'] + list(default_cflags) + sys.argv); return
    cflags, output, srcs = parse_argv()
    objs = map(lambda src: remove_filext(os.path.basename(src)) + '.o', srcs)
    call_e([cc, '-emit-llvm', '-c'] + list(default_cflags) + cflags + srcs)
    link(objs, output)
    map(os.unlink, objs)
if __name__ == '__main__': main()
